<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ê–π—Ç—Ä–µ–∫–∏–Ω–≥: —Ñ–∏–∫—Å–∞—Ü–∏–∏ –∏ AOI</title>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      line-height: 1.5;
      background-color: #f7f7f7;
      color: #222;
      overflow-y: scroll;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    .block {
      width: 100%;
      padding: 2rem;
      box-sizing: border-box;
      background-color: #ffffff;
      border-bottom: 1px solid #ddd;
    }

    h1, h2 {
      margin-top: 0;
    }

    canvas {
      display: block;
      margin: 1rem auto;
      width: calc(100% - 2rem);
      height: auto;
      aspect-ratio: 16 / 9;
      border: 2px solid #444;
      background-color: #eaeaea;
    }

    .participant-controls {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .participant-controls label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .participant-controls input[type="text"] {
      flex: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <section class="block" id="intro">
      <h1>–ê–Ω–∞–ª–∏–∑ –∞–π—Ç—Ä–µ–∫–∏–Ω–≥–æ–≤–æ–≥–æ —á—Ç–µ–Ω–∏—è</h1>
      <p>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, Excel —Å —Ñ–∏–∫—Å–∞—Ü–∏—è–º–∏ –∏ JSON —Å AOI –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞.</p>
    </section>

    <section class="block" id="upload-image">
      <h2>1. –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</h2>
      <input type="file" id="imageLoader" accept="image/*" />
    </section>

    <section class="block" id="upload-data">
      <h2>2. –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∏–∫—Å–∞—Ü–∏–π (.xlsx)</h2>
      <input type="file" id="dataLoader" accept=".xlsx" />
      <div id="participantList" class="participant-controls"></div>
      <button onclick="playFixations()">‚ñ∂ –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏</button>
    </section>

    <section class="block" id="fixation-stats">
      <h2>6. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ñ–∏–∫—Å–∞—Ü–∏–π</h2>
      <ul id="fixationSummary"></ul>
    </section>

    <section class="block" id="upload-aoi">
      <h2>3. –ó–∞–≥—Ä—É–∑–∫–∞ AOI (.json)</h2>
      <input type="file" id="aoiLoader" accept=".json" />
    </section>

    <section class="block">
      <button onclick="exportAoiStatsToXLSX()">üíæ –°–∫–∞—á–∞—Ç—å —Ç–∞–±–ª–∏—Ü—É –∞–Ω–∞–ª–∏–∑–∞ (.xlsx)</button>
    </section>

    <section class="block" id="settings-block">
      <h2>4. –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —ç–∫—Ä–∞–Ω–∞</h2>
      <label>–î–∏–∞–≥–æ–Ω–∞–ª—å –º–æ–Ω–∏—Ç–æ—Ä–∞ (–¥—é–π–º—ã): <input type="number" id="screenDiagonal" value="24" step="0.1"></label><br>
      <label>–°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Å—Ç–æ—Ä–æ–Ω: <input type="text" id="aspectRatio" value="16:9"></label><br>
      <label>–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –≥–ª–∞–∑ –¥–æ —ç–∫—Ä–∞–Ω–∞ (—Å–º): <input type="number" id="viewDistance" value="60"></label><br>
      <p id="degPerUnit">–ì—Ä–∞–¥—É—Å—ã –Ω–∞ –µ–¥–∏–Ω–∏—Ü—É –Ω–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã: <span id="degResult">42.63</span></p>
      <button onclick="calculateVisualAngle()">–í—ã—á–∏—Å–ª–∏—Ç—å</button>
    </section>

    <section class="block" id="visualization">
      <h2>5. –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è</h2>
      <canvas id="canvas"></canvas>
    </section>
    <section class="block" id="aoi-stats">
      <h2>7. –¢–∞–±–ª–∏—Ü–∞ –∞–Ω–∞–ª–∏–∑–∞ –ø–æ AOI</h2>
      <table border="1" id="aoiStatsTable">
        <thead>
          <tr>
            <th>–£—á–∞—Å—Ç–Ω–∏–∫</th>
            <th>TTF (–º—Å)</th>
            <th>–í—Ä–µ–º—è —Ñ–∏–∫—Å–∞—Ü–∏–π</th>
            <th>–ü–µ—Ä–≤–∞—è —Ñ–∏–∫—Å–∞—Ü–∏—è</th>
            <th>–°—Ä. —Ñ–∏–∫—Å–∞—Ü–∏—è</th>
            <th>–ö–æ–ª-–≤–æ —Ñ–∏–∫—Å–∞—Ü–∏–π</th>
            <th>–ö–æ–ª-–≤–æ —Å–∞–∫–∫–∞–¥</th>
            <th>–°–∞–∫–∫–∞–¥—ã –æ–±—â.</th>
            <th>–°–∞–∫–∫–∞–¥—ã –ø—Ä—è–º.</th>
            <th>–°—Ä. –¥–ª–∏–Ω–∞ —Å–∞–∫–∫–∞–¥—ã –æ–±—â.</th>
            <th>–°—Ä. –¥–ª–∏–Ω–∞ —Å–∞–∫–∫–∞–¥—ã –ø—Ä—è–º.</th>
          </tr>
        </thead>
        <tbody id="aoiStatsBody"></tbody>
      </table>
    </section>

  </div>

  <script src="./xlsx.full.min.js"></script>
  <script>
    function exportAoiStatsToXLSX() {
      const headers = [
        ["–£—á–∞—Å—Ç–Ω–∏–∫", "TTF (–º—Å)", "–í—Ä–µ–º—è —Ñ–∏–∫—Å–∞—Ü–∏–π", "–ü–µ—Ä–≤–∞—è —Ñ–∏–∫—Å–∞—Ü–∏—è", "–°—Ä. —Ñ–∏–∫—Å–∞—Ü–∏—è", "–ö–æ–ª-–≤–æ —Ñ–∏–∫—Å–∞—Ü–∏–π", "–ö–æ–ª-–≤–æ —Å–∞–∫–∫–∞–¥", "–°–∞–∫–∫–∞–¥—ã –æ–±—â.", "–°–∞–∫–∫–∞–¥—ã –ø—Ä—è–º.", "–°—Ä. –¥–ª–∏–Ω–∞ —Å–∞–∫–∫–∞–¥—ã –æ–±—â.", "–°—Ä. –¥–ª–∏–Ω–∞ —Å–∞–∫–∫–∞–¥—ã –ø—Ä—è–º."]
      ];
      const rows = participants.filter(p => p.stats && p.visible).map(p => {
        const s = p.stats;
        return [
          p.name,
          s.ttf,
          s.fixTime,
          s.firstFix,
          s.meanFix,
          s.allFix,
          s.saccadCount,
          s.saccadAmplCommon.toFixed(3),
          s.saccadAmplCommonStraight.toFixed(3),
          s.saccadAmpl.toFixed(3),
          s.saccadAmplStraight.toFixed(3)
        ];
      });
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(headers.concat(rows));
      XLSX.utils.book_append_sheet(wb, ws, "AOI Stats");
      XLSX.writeFile(wb, "aoi_stats.xlsx");
    }
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    var degPerUnit = 42.63;
    var velocityThresholdDegPerSec = 70;
    var fixTMin = 0.06;
    const speedScale = 2.0;
    var realScrW = 47.6;
    var realScrH = 26.8;
    var realDist = 61;

    function calcGrad(ratio, width) {
      const isLeft = ratio < 0.5;
      const halfAngle = Math.atan(width/2/realDist);
      const isLeftHalf = ratio<0.5;
      const deltaWidth = isLeft ? (0.5-ratio)*width : (ratio-0.5)*width;
      const deltaAngle = Math.atan(deltaWidth/realDist);
      return (isLeft ? halfAngle-deltaAngle : halfAngle+deltaAngle)*180.0/Math.PI;
    }
    function calcGrads() {
      participants.forEach(p => {
        for (let index = 0; index < p.data.length; index++) {
          p.data[index].gradX = calcGrad(p.data[index].x, realScrW);
          p.data[index].gradY = calcGrad(p.data[index].y, realScrH);
        }
      });
    }

    function medFilter(p, c, n) { //[prev, cur, next]
      let buf = ([p, c, n]).sort();
      if (c>buf[1]) {
        return buf[1];
      }
      return c;
    }
    function formFiltered() {
      participants.forEach(p => {
        p.filtered = [p.data[0]];
        for (let i = 1; i < p.data.length-1; i++) {
          const point = p.data[i];
          let x = medFilter(p.filtered[i-1].x, point.x, p.data[i+1].x);
          let y = medFilter(p.filtered[i-1].y, point.y, p.data[i+1].y);

          point.filtered = (x!=point.x || y!=point.y);
          point.x = x;
          point.y = y;
          p.filtered.push(point);
        }
        p.filtered.push(p.data.at(-1));
      });
    }

    function getGradDistance(p1,p2) {
      if (p1.x == p2.x && p1.y == p2.y) return 0;

      const z = realDist;
      
      const sx = (-0.5+p1.x)*realScrW;
      const sy = (0.5-p1.y)*realScrH;

      const ex = (-0.5+p2.x)*realScrW;
      const ey = (0.5-p2.y)*realScrH;

      const scalar = sx*ex+sy*ey+z*z;
      const sd = Math.sqrt(sx*sx+sy*sy+z*z);
      const ed = Math.sqrt(ex*ex+ey*ey+z*z);
      const dist = Math.acos(scalar/sd/ed)*180.0/Math.PI;

      return dist;
    }
    console.log(getGradDistance({x:0, y:0.5}, {x: 0.1, y:0}))

    function getGradVelocity(p1, p2) {
      const dt = (p2.time - p1.time)
      if (dt <= 0) return 0;
      
      return getGradDistance(p1, p2) / dt;
    }

    function centroidData(array) {
      const res = {x: 0, y: 0, r: 0};
      for (let index = 0; index < array.length; index++) {
        const element = array[index];
        res.x += element.x;
        res.y += element.y;
      }
      res.x /= array.length;
      res.y /= array.length;

      
      for (let index = 0; index < array.length; index++) {
        const element = array[index];
        const rad = Math.sqrt(res.x*res.x+res.y+res.y);
        if (rad > res.r) res.r = rad;
      }
      return res;
    }

    function updateAoiStatsTable() {
      const tbody = document.getElementById("aoiStatsBody");
      tbody.innerHTML = "";
      participants.forEach(p => {
        if (!p.visible || !p.stats) return;
        const s = p.stats;
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${p.name}</td>
          <td>${s.ttf.toFixed(0)}</td>
          <td>${s.fixTime.toFixed(5)}</td>
          <td>${s.firstFix.toFixed(5)}</td>
          <td>${s.meanFix.toFixed(5)}</td>
          <td>${s.allFix}</td>
          <td>${s.saccadCount}</td>
          <td>${s.saccadAmplCommon.toFixed(3)}</td>
          <td>${s.saccadAmplCommonStraight.toFixed(3)}</td>
          <td>${s.saccadAmpl.toFixed(3)}</td>
          <td>${s.saccadAmplStraight.toFixed(3)}</td>
        `;
        tbody.appendChild(row);
      });
    }


    function calculateFixationsSaccades() {
      degPerUnit = parseFloat(document.getElementById("degResult").textContent);
      const threshold = velocityThresholdDegPerSec;


      participants.forEach(p => {
        let isFix = false;
        p.groups = [{isFixation: false, data: []}];

        ctx.lineWidth = 1.0;
        let fixGroup = [];
        for (let i = 0; i < p.data.length-1; i++) { //-1?  
          const p1 = p.filtered[i];
          const p2 = p.filtered[i+1];
          let velocity = getGradVelocity(p1, p2); 
          p1.velocity = velocity;
          isFix = velocity < threshold;

          if (isFix) {                  // fix point encountered
            fixGroup.push(p1);
          } else {                      // sac point encountered
            //console.log("fx", fixGroup)
            if (fixGroup.length > 1) {  // if we had fix points before cur sac point
              //console.log("cd", fixGroup.at(-1).time - fixGroup[0].time )
              if (fixGroup.at(-1).time - fixGroup[0].time < fixTMin) {  // small fix, add to prev sac
                p.groups.at(-1).data.push(...fixGroup);
                fixGroup = [];
              } else {                  // fixGroup is correct, add it to groups and start new sac
                p.groups.push({isFix: true, data: [...fixGroup]});
                p.groups.push({isFix: false, data: []});
                fixGroup = [];
              }
            }
            p.groups.at(-1).data.push(p1);
          }
        }
        if (p.groups[0].data.length <= 0) p.groups.shift();
        // we are losing last point here...

        let left = 0;
        p.groups.forEach(g => {
          g.centroid = centroidData(g.data);
          g.time = g.data[0].time;
          g.duration = g.data.at(-1).time - g.time;
          g.distance = 0;
          g.straight = getGradDistance(g.data[0], g.data.at(-1));

          for (let i = 0; i < g.data.length; i++) { //-1?
            if (i< g.data.length-1) g.distance += getGradDistance(g.data[i], g.data[i+1]);

            const velocity = g.data[i].velocity; 
            if (g.isFix)
              ctx.strokeStyle = "darkred";
            else 
              ctx.strokeStyle = "red";
            ctx.beginPath(); // Start a new path
            ctx.moveTo(left+i+0.5, 0);
            ctx.lineTo(left+i+0.5, 2.5);
            ctx.lineTo(left+i+0.5, velocity/speedScale+0.5);
            ctx.closePath();
            ctx.stroke();
          };
          
          if (g.isFix) {
            ctx.strokeStyle = "darkblue";
          } else {
            ctx.strokeStyle = "blue";
          }
          ctx.beginPath(); // Start a new path
          ctx.moveTo(left+0.5, threshold/speedScale+0.5);
          ctx.lineTo(left+g.data.length+0.5, threshold/speedScale+0.5);
          ctx.closePath();
          ctx.stroke();
          left += g.data.length;
        });


        p.stats = {
          ttf: 0,
          fixTime: 0,
          firstFix: 0,
          meanFix: 0,
          allFix: 0,
          saccadCount: 0,
          saccadAmpl: 0,
          saccadAmplCommon: 0,
          saccadAmplStraight: 0,
          saccadAmplCommonStraight: 0
        }
        let isFirstFixFound = false;
        p.groups.forEach(g => {
          if (g.isFix) {
            if (!isFirstFixFound) {
              isFirstFixFound = true;
              p.stats.ttf = g.time;
              p.stats.firstFix = g.duration;
            }
            p.stats.fixTime += g.duration;
            p.stats.allFix += 1;
          } else {
            p.stats.saccadCount += 1;
            p.stats.saccadAmplCommon += g.distance;
            p.stats.saccadAmplCommonStraight += g.straight;
          }
          p.stats.meanFix = p.stats.fixTime / p.stats.allFix;
          p.stats.saccadAmpl = p.stats.saccadAmplCommon / p.stats.saccadCount;
          p.stats.saccadAmplStraight = p.stats.saccadAmplCommonStraight / p.stats.saccadCount;
        });
      });
      console.log(participants);
      updateAoiStatsTable();

    }

    const participantListDiv = document.getElementById("participantList");

    let image = new Image();
    let participants = [];
    let aoiList = [];
    let animationFrame = null;
    let playbackIndex = 0;

    document.getElementById("imageLoader").addEventListener("change", handleImage, false);
    document.getElementById("dataLoader").addEventListener("change", handleData, false);
    document.getElementById("aoiLoader").addEventListener("change", handleAoi, false);
    window.addEventListener("resize", drawImageAndFixations);

    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.width * 9 / 16;
    }

    function getRandomColor() {
      const r = Math.floor(Math.random() * 200);
      const g = Math.floor(Math.random() * 200);
      const b = Math.floor(Math.random() * 200);
      return `rgb(${r},${g},${b})`;
    }

    function handleImage(e) {
      const reader = new FileReader();
      reader.onload = function (event) {
        image.onload = function () {
          resizeCanvasToDisplaySize();
          drawImageAndFixations();
        };
        image.src = event.target.result;
      };
      reader.readAsDataURL(e.target.files[0]);
    }

    function handleData(e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (evt) {
        const data = new Uint8Array(evt.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

        let current = null;
        let count = 0;
        participants = [];
        console.log("R",rows);
        rows.forEach(row => {
          if (!row || row.length < 2) return;
          const header = String(row[0]).trim();
          if (header === "TIME") {
            count++;
            current = {
              name: file.name.replace(/\.xlsx$/, '') + "_P" + count,
              data: [],
              color: getRandomColor(),
              visible: true
            };
            console.log(current)
            participants.push(current);
          } else if (current && row.length >= 8) {
            current.data.push({
              time: +row[0],
              time2: +row[1],
              validity: +row[2],
              x: +row[3],
              y: +row[4],
              z: +row[5],
              lp: +row[6],
              rp: +row[7]
            });
          }
        });

        console.log(participants)
        formFiltered();
        calculateFixationsSaccades();
        updateParticipantUI();
        drawImageAndFixations();
      };
      reader.readAsArrayBuffer(file);
    }

    function updateParticipantUI() {
      participantListDiv.innerHTML = "";
      participants.forEach((p, i) => {
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = p.visible;
        checkbox.addEventListener("change", () => {
          p.visible = checkbox.checked;
          drawImageAndFixations();
        });

        const input = document.createElement("input");
        input.type = "text";
        input.value = p.name;
        input.addEventListener("input", () => {
          p.name = input.value;
        });

        label.appendChild(checkbox);
        label.appendChild(input);
        participantListDiv.appendChild(label);
      });
    }

    function handleAoi(e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (event) {
        try {
          const json = JSON.parse(event.target.result);
          aoiList = json.list || [];
          drawImageAndFixations();
        } catch (err) {
          alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ AOI-—Ñ–∞–π–ª–∞.");
        }
      };
      reader.readAsText(file);
    }

    function drawImageAndFixations(showCount = Infinity) {
      const stats = [];
      if (!image.src) return;
      resizeCanvasToDisplaySize();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 1;

      const scaleX = canvas.width;
      const scaleY = canvas.height;

      participants.forEach(p => {
        if (!p.visible) return;
        ctx.fillStyle = p.color;
        const data = p.data.slice(0, showCount);
        data.forEach(pt => {
          if (pt.validity > 0 && pt.x >= 0 && pt.x <= 1 && pt.y >= 0 && pt.y <= 1) {
            const cx = pt.x * scaleX;
            const cy = pt.y * scaleY;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        });

      });

      updateFixationStats(stats);

      if (aoiList.length > 0) {
        aoiList.forEach((aoi) => {
          const left = aoi.left * canvas.width;
          const top = aoi.top * canvas.height;
          const right = aoi.right * canvas.width;
          const bottom = aoi.bottom * canvas.height;
          const width = right - left;
          const height = bottom - top;

          ctx.strokeStyle = "rgba(0,195,0,0.8)";
          ctx.lineWidth = 2;
          ctx.strokeRect(left, top, width, height);

          if (aoi.name) {
            ctx.font = "14px sans-serif";
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillText(aoi.name, left + 4, top + 16);
          }
        });
      }
    }

    function updateFixationStats(stats) {
      const list = document.getElementById("fixationSummary");
      list.innerHTML = "";
      stats.forEach(s => {
        const li = document.createElement("li");
        li.textContent = s;
        list.appendChild(li);
      });
    }

    function playFixations() {
      cancelAnimationFrame(animationFrame);
      let maxPoints = Math.max(...participants.map(p => p.data.length));
      playbackIndex = 0;

      function step() {
        playbackIndex++;
        drawImageAndFixations(playbackIndex);
        if (playbackIndex < maxPoints) {
          animationFrame = requestAnimationFrame(step);
        }
      }

      step();
    }


    function calculateVisualAngle() {
      const diag = parseFloat(document.getElementById("screenDiagonal").value);
      const ratio = document.getElementById("aspectRatio").value.split(":").map(Number);
      const dist = parseFloat(document.getElementById("viewDistance").value);
      if (ratio.length !== 2 || !diag || !dist) return;

      const aspectW = ratio[0];
      const aspectH = ratio[1];
      const diagInCm = diag * 2.54;

      const aspectRatio = Math.sqrt(aspectW ** 2 + aspectH ** 2);
      const widthCm = diagInCm * (aspectW / aspectRatio);

      const degPerUnit = 2 * Math.atan((widthCm / 2) / dist) * (180 / Math.PI);
      document.getElementById("degResult").textContent = degPerUnit.toFixed(2);
    }
  </script>
</body>
</html>
