<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Айтрекинг: фиксации и AOI</title>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      line-height: 1.5;
      background-color: #f7f7f7;
      color: #222;
      overflow-y: scroll;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    .block {
      width: 100%;
      padding: 2rem;
      box-sizing: border-box;
      background-color: #ffffff;
      border-bottom: 1px solid #ddd;
    }

    h1, h2 {
      margin-top: 0;
    }

    canvas {
      display: block;
      margin: 1rem auto;
      width: calc(100% - 2rem);
      height: auto;
      aspect-ratio: 16 / 9;
      border: 2px solid #444;
      background-color: #eaeaea;
    }

    .participant-controls {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .participant-controls label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .participant-controls input[type="text"] {
      flex: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <section class="block" id="intro">
      <h1>Анализ айтрекингового чтения</h1>
      <p>Загрузите изображение, Excel с фиксациями и JSON с AOI для визуального анализа.</p>
    </section>

    <section class="block" id="upload-image">
      <h2>1. Загрузка изображения</h2>
      <input type="file" id="imageLoader" accept="image/*" />
    </section>

    <section class="block" id="upload-data">
      <h2>2. Загрузка фиксаций (.xlsx)</h2>
      <input type="file" id="dataLoader" accept=".xlsx" />
      <div id="participantList" class="participant-controls"></div>
      <button onclick="playFixations()">▶ Воспроизвести</button>
    </section>

    <section class="block" id="fixation-stats">
      <h2>6. Статистика фиксаций</h2>
      <ul id="fixationSummary"></ul>
    </section>

    <section class="block" id="upload-aoi">
      <h2>3. Загрузка AOI (.json)</h2>
      <input type="file" id="aoiLoader" accept=".json" />
    </section>

    <section class="block" id="settings-block">
      <h2>4. Настройки экрана</h2>
      <label>Диагональ монитора (дюймы): <input type="number" id="screenDiagonal" value="24" step="0.1"></label><br>
      <label>Соотношение сторон: <input type="text" id="aspectRatio" value="16:9"></label><br>
      <label>Расстояние от глаз до экрана (см): <input type="number" id="viewDistance" value="60"></label><br>
      <p id="degPerUnit">Градусы на единицу нормированной координаты: <span id="degResult">—</span></p>
      <button onclick="calculateVisualAngle()">Вычислить</button>
    </section>

    <section class="block" id="visualization">
      <h2>5. Визуализация</h2>
      <canvas id="canvas"></canvas>
    </section>
  </div>

  <script src="./xlsx.full.min.js"></script>
  <script>
    function detectFixations(data, velocityThresholdDegPerSec) {
      const fixations = [];
      const degPerUnit = parseFloat(document.getElementById("degResult").textContent);
      if (!degPerUnit || isNaN(degPerUnit)) return fixations;
      const threshold = velocityThresholdDegPerSec;

      let fixation = [];
      for (let i = 1; i < data.length; i++) {
        const p1 = data[i - 1];
        const p2 = data[i];
        const dt = (p2.time - p1.time) // 1000; // время в секундах
        if (dt <= 0) continue;

        const dx = (p2.x - p1.x) * degPerUnit;
        const dy = (p2.y - p1.y) * degPerUnit;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const velocity = dist / dt;

        if (velocity < threshold) {
          fixation.push(p2);
        } else {
          if (fixation.length > 1) fixations.push([...fixation]);
          fixation = [];
        }
      }
      if (fixation.length > 1) fixations.push(fixation);
      return fixations;
    }

    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const participantListDiv = document.getElementById("participantList");

    let image = new Image();
    let participants = [];
    let aoiList = [];
    let animationFrame = null;
    let playbackIndex = 0;

    document.getElementById("imageLoader").addEventListener("change", handleImage, false);
    document.getElementById("dataLoader").addEventListener("change", handleData, false);
    document.getElementById("aoiLoader").addEventListener("change", handleAoi, false);
    window.addEventListener("resize", drawImageAndFixations);

    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.width * 9 / 16;
    }

    function getRandomColor() {
      const r = Math.floor(Math.random() * 200);
      const g = Math.floor(Math.random() * 200);
      const b = Math.floor(Math.random() * 200);
      return `rgb(${r},${g},${b})`;
    }

    function handleImage(e) {
      const reader = new FileReader();
      reader.onload = function (event) {
        image.onload = function () {
          resizeCanvasToDisplaySize();
          drawImageAndFixations();
        };
        image.src = event.target.result;
      };
      reader.readAsDataURL(e.target.files[0]);
    }

    function handleData(e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (evt) {
        const data = new Uint8Array(evt.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

        let current = null;
        let count = 0;
        participants = [];

        rows.forEach(row => {
          if (!row || row.length < 2) return;
          const header = String(row[0]).trim();
          if (header === "TIME" && row[1] === "Valid") {
            count++;
            current = {
              name: file.name.replace(/\.xlsx$/, '') + "_P" + count,
              data: [],
              color: getRandomColor(),
              visible: true
            };
            participants.push(current);
          } else if (current && row.length >= 8) {
            current.data.push({
              time: +row[0],
              time2: +row[1],
              validity: +row[2],
              x: +row[3],
              y: +row[4],
              z: +row[5],
              lp: +row[6],
              rp: +row[7]
            });
          }
        });

        updateParticipantUI();
        participants.forEach(p => {
          p.fixations = detectFixations(p.data, 70);
        });
        drawImageAndFixations();
      };
      reader.readAsArrayBuffer(file);
    }

    function updateParticipantUI() {
      participantListDiv.innerHTML = "";
      participants.forEach((p, i) => {
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = p.visible;
        checkbox.addEventListener("change", () => {
          p.visible = checkbox.checked;
          drawImageAndFixations();
        });

        const input = document.createElement("input");
        input.type = "text";
        input.value = p.name;
        input.addEventListener("input", () => {
          p.name = input.value;
        });

        label.appendChild(checkbox);
        label.appendChild(input);
        participantListDiv.appendChild(label);
      });
    }

    function handleAoi(e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (event) {
        try {
          const json = JSON.parse(event.target.result);
          aoiList = json.list || [];
          drawImageAndFixations();
        } catch (err) {
          alert("Ошибка при чтении AOI-файла.");
        }
      };
      reader.readAsText(file);
    }

    function drawImageAndFixations(showCount = Infinity) {
      const stats = [];
      if (!image.src) return;
      resizeCanvasToDisplaySize();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 1;

      const scaleX = canvas.width;
      const scaleY = canvas.height;

      participants.forEach(p => {
        if (!p.visible) return;
        ctx.fillStyle = p.color;
        const data = p.data.slice(0, showCount);
        data.forEach(pt => {
          if (pt.validity > 0 && pt.x >= 0 && pt.x <= 1 && pt.y >= 0 && pt.y <= 1) {
            const cx = pt.x * scaleX;
            const cy = pt.y * scaleY;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        });

        if (p.fixations && p.fixations.length > 0) {
          p.fixations.forEach(fix => {
            const avgX = fix.reduce((s, pt) => s + pt.x, 0) / fix.length;
            const avgY = fix.reduce((s, pt) => s + pt.y, 0) / fix.length;
            const cx = avgX * scaleX;
            const cy = avgY * scaleY;
            ctx.strokeStyle = p.color;
            ctx.beginPath();
            ctx.arc(cx, cy, 10, 0, Math.PI * 2);
            ctx.stroke();
          });
          stats.push(`${p.name}: ${p.fixations.length} фиксаций`);

          if (pt.validity > 0 && pt.x >= 0 && pt.x <= 1 && pt.y >= 0 && pt.y <= 1) {
            const cx = pt.x * scaleX;
            const cy = pt.y * scaleY;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      });
      console.log(participants)
      updateFixationStats(stats);

      if (aoiList.length > 0) {
        aoiList.forEach((aoi) => {
          const left = aoi.left * canvas.width;
          const top = aoi.top * canvas.height;
          const right = aoi.right * canvas.width;
          const bottom = aoi.bottom * canvas.height;
          const width = right - left;
          const height = bottom - top;

          ctx.strokeStyle = "rgba(0,195,0,0.8)";
          ctx.lineWidth = 2;
          ctx.strokeRect(left, top, width, height);

          if (aoi.name) {
            ctx.font = "14px sans-serif";
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillText(aoi.name, left + 4, top + 16);
          }
        });
      }
    }

    function updateFixationStats(stats) {
      const list = document.getElementById("fixationSummary");
      list.innerHTML = "";
      stats.forEach(s => {
        const li = document.createElement("li");
        li.textContent = s;
        list.appendChild(li);
      });
    }

    function playFixations() {
      cancelAnimationFrame(animationFrame);
      let maxPoints = Math.max(...participants.map(p => p.data.length));
      playbackIndex = 0;

      function step() {
        playbackIndex++;
        drawImageAndFixations(playbackIndex);
        if (playbackIndex < maxPoints) {
          animationFrame = requestAnimationFrame(step);
        }
      }

      step();
    }


    function calculateVisualAngle() {
      const diag = parseFloat(document.getElementById("screenDiagonal").value);
      const ratio = document.getElementById("aspectRatio").value.split(":").map(Number);
      const dist = parseFloat(document.getElementById("viewDistance").value);
      if (ratio.length !== 2 || !diag || !dist) return;

      const aspectW = ratio[0];
      const aspectH = ratio[1];
      const diagInCm = diag * 2.54;

      const aspectRatio = Math.sqrt(aspectW ** 2 + aspectH ** 2);
      const widthCm = diagInCm * (aspectW / aspectRatio);

      const degPerUnit = 2 * Math.atan((widthCm / 2) / dist) * (180 / Math.PI);
      document.getElementById("degResult").textContent = degPerUnit.toFixed(2);
    }
  </script>
</body>
</html>
