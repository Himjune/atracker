<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Айтрекинг: фиксации и AOI</title>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      line-height: 1.5;
      background-color: #f7f7f7;
      color: #222;
      overflow-y: scroll;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    .block {
      width: 100%;
      padding: 2rem;
      box-sizing: border-box;
      background-color: #ffffff;
      border-bottom: 1px solid #ddd;
    }

    h1, h2 {
      margin-top: 0;
    }

    canvas {
      display: block;
      margin: 1rem auto;
      width: calc(100% - 2rem);
      height: auto;
      aspect-ratio: 16 / 9;
      border: 2px solid #444;
      background-color: #eaeaea;
    }

    .participant-controls {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .participant-controls label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .participant-controls input[type="text"] {
      flex: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <section class="block" id="intro">
      <h1>Анализ айтрекингового чтения</h1>
      <p>Загрузите изображение, Excel с фиксациями и JSON с AOI для визуального анализа.</p>
    </section>

    <section class="block" id="upload-image">
      <h2>1. Загрузка изображения</h2>
      <input type="file" id="imageLoader" accept="image/*" />
    </section>

    <section class="block" id="upload-data">
      <h2>2. Загрузка фиксаций (.xlsx)</h2>
      <input type="file" id="dataLoader" accept=".xlsx" />
      <div id="participantList" class="participant-controls"></div>
      <button onclick="playFixations()">▶ Воспроизвести</button>
    </section>

    <section class="block" id="fixation-stats">
      <h2>6. Статистика фиксаций</h2>
      <ul id="fixationSummary"></ul>
    </section>

    <section class="block" id="upload-aoi">
      <h2>3. Загрузка AOI (.json)</h2>
      <input type="file" id="aoiLoader" accept=".json" />
    </section>

    <section class="block" id="settings-block">
      <h2>4. Настройки экрана</h2>
      <label>Диагональ монитора (дюймы): <input type="number" id="screenDiagonal" value="24" step="0.1"></label><br>
      <label>Соотношение сторон: <input type="text" id="aspectRatio" value="16:9"></label><br>
      <label>Расстояние от глаз до экрана (см): <input type="number" id="viewDistance" value="60"></label><br>
      <p id="degPerUnit">Градусы на единицу нормированной координаты: <span id="degResult">42.63</span></p>
      <button onclick="calculateVisualAngle()">Вычислить</button>
    </section>

    <section class="block" id="visualization">
      <h2>5. Визуализация</h2>
      <canvas id="canvas"></canvas>
    </section>
  </div>

  <script src="./xlsx.full.min.js"></script>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    var degPerUnit = 42.5;
    var velocityThresholdDegPerSec = 70;
    var fixTMin = 0.06;

    function getGradVelocity(p1, p2) {
      const dt = (p2.time - p1.time)
      if (dt <= 0) return 0;

      const dx = (p2.x - p1.x) * degPerUnit;
      const dy = (p2.y - p1.y) * degPerUnit;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const velosity = dist / dt;
      console.log(velosity, p2, p1, dx, dy, dist, dt)
      return velosity;
    }

    function calculateFixationsSaccades() {
      degPerUnit = parseFloat(document.getElementById("degResult").textContent);
      const threshold = velocityThresholdDegPerSec;

      let group = [];
      participants.forEach(p => {
        let isFixation = getGradVelocity(p.data[0], p.data[1]) < threshold;
        p.fixations = [{data: []}];
        p.saccades = [{data: []}];
        ctx.lineWidth = 1.0;
        ctx.beginPath(); // Start a new path
        for (let i = 0; i < p.data.length-1; i++) { //-1?
          const p1 = p.data[i];
          const p2 = p.data[i+1];
          let velocity = getGradVelocity(p1, p2); 
          ctx.moveTo(i,0);
          ctx.lineTo(i,velocity/7);
          console.log(velocity);

          if (velocity < threshold) {   // fix point
            if (isFixation) {           // was fix and now fix point
              p.fixations.at(-1).data.push(p1);
            } else {                    // was sac and now fix point
              p.fixations.push({data: [p1]});
              isFixation = true;
            }
          } else {                      // sac point
            if (isFixation) {           // was fix and now sac
              const lastFix = p.fixations.at(-1)
              if (lastFix.length>1 && lastFix.data.at(-1).time - lastFix.data[0].time < fixTMin) {  // small fix before sac
                p.saccades.at(-1).push(...lastFix.data);
                p.fixations.pop();
                p.saccades.at(-1).data.push(p1);
              } else {  // start new sac after valid fix
                p.saccades.push({data: [p1]});
              }
              isFixation = false;
            } else {                    // was sac and now sac
              p.saccades.at(-1).data.push(p1);
            }
          }
        }
        ctx.stroke(); // Render the path
      });

      ctx.strokeStyle = "blue"
        ctx.beginPath(); // Start a new path
          ctx.moveTo(0,10);
          ctx.lineTo(3000,10);
        ctx.stroke(); // Render the path
      console.log(participants);
    }

    const participantListDiv = document.getElementById("participantList");

    let image = new Image();
    let participants = [];
    let aoiList = [];
    let animationFrame = null;
    let playbackIndex = 0;

    document.getElementById("imageLoader").addEventListener("change", handleImage, false);
    document.getElementById("dataLoader").addEventListener("change", handleData, false);
    document.getElementById("aoiLoader").addEventListener("change", handleAoi, false);
    window.addEventListener("resize", drawImageAndFixations);

    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.width * 9 / 16;
    }

    function getRandomColor() {
      const r = Math.floor(Math.random() * 200);
      const g = Math.floor(Math.random() * 200);
      const b = Math.floor(Math.random() * 200);
      return `rgb(${r},${g},${b})`;
    }

    function handleImage(e) {
      const reader = new FileReader();
      reader.onload = function (event) {
        image.onload = function () {
          resizeCanvasToDisplaySize();
          drawImageAndFixations();
        };
        image.src = event.target.result;
      };
      reader.readAsDataURL(e.target.files[0]);
    }

    function handleData(e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (evt) {
        const data = new Uint8Array(evt.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

        let current = null;
        let count = 0;
        participants = [];

        rows.forEach(row => {
          if (!row || row.length < 2) return;
          const header = String(row[0]).trim();
          if (header === "TIME" && row[1] === "Valid") {
            count++;
            current = {
              name: file.name.replace(/\.xlsx$/, '') + "_P" + count,
              data: [],
              color: getRandomColor(),
              visible: true
            };
            participants.push(current);
          } else if (current && row.length >= 8) {
            current.data.push({
              time: +row[0],
              time2: +row[1],
              validity: +row[2],
              x: +row[3],
              y: +row[4],
              z: +row[5],
              lp: +row[6],
              rp: +row[7]
            });
          }
        });
        calculateFixationsSaccades();
        updateParticipantUI();
        drawImageAndFixations();
      };
      reader.readAsArrayBuffer(file);
    }

    function updateParticipantUI() {
      participantListDiv.innerHTML = "";
      participants.forEach((p, i) => {
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = p.visible;
        checkbox.addEventListener("change", () => {
          p.visible = checkbox.checked;
          drawImageAndFixations();
        });

        const input = document.createElement("input");
        input.type = "text";
        input.value = p.name;
        input.addEventListener("input", () => {
          p.name = input.value;
        });

        label.appendChild(checkbox);
        label.appendChild(input);
        participantListDiv.appendChild(label);
      });
    }

    function handleAoi(e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (event) {
        try {
          const json = JSON.parse(event.target.result);
          aoiList = json.list || [];
          drawImageAndFixations();
        } catch (err) {
          alert("Ошибка при чтении AOI-файла.");
        }
      };
      reader.readAsText(file);
    }

    function drawImageAndFixations(showCount = Infinity) {
      const stats = [];
      if (!image.src) return;
      resizeCanvasToDisplaySize();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 1;

      const scaleX = canvas.width;
      const scaleY = canvas.height;

      participants.forEach(p => {
        if (!p.visible) return;
        ctx.fillStyle = p.color;
        const data = p.data.slice(0, showCount);
        data.forEach(pt => {
          if (pt.validity > 0 && pt.x >= 0 && pt.x <= 1 && pt.y >= 0 && pt.y <= 1) {
            const cx = pt.x * scaleX;
            const cy = pt.y * scaleY;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        });

      });
      updateFixationStats(stats);

      if (aoiList.length > 0) {
        aoiList.forEach((aoi) => {
          const left = aoi.left * canvas.width;
          const top = aoi.top * canvas.height;
          const right = aoi.right * canvas.width;
          const bottom = aoi.bottom * canvas.height;
          const width = right - left;
          const height = bottom - top;

          ctx.strokeStyle = "rgba(0,195,0,0.8)";
          ctx.lineWidth = 2;
          ctx.strokeRect(left, top, width, height);

          if (aoi.name) {
            ctx.font = "14px sans-serif";
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillText(aoi.name, left + 4, top + 16);
          }
        });
      }
    }

    function updateFixationStats(stats) {
      const list = document.getElementById("fixationSummary");
      list.innerHTML = "";
      stats.forEach(s => {
        const li = document.createElement("li");
        li.textContent = s;
        list.appendChild(li);
      });
    }

    function playFixations() {
      cancelAnimationFrame(animationFrame);
      let maxPoints = Math.max(...participants.map(p => p.data.length));
      playbackIndex = 0;

      function step() {
        playbackIndex++;
        drawImageAndFixations(playbackIndex);
        if (playbackIndex < maxPoints) {
          animationFrame = requestAnimationFrame(step);
        }
      }

      step();
    }


    function calculateVisualAngle() {
      const diag = parseFloat(document.getElementById("screenDiagonal").value);
      const ratio = document.getElementById("aspectRatio").value.split(":").map(Number);
      const dist = parseFloat(document.getElementById("viewDistance").value);
      if (ratio.length !== 2 || !diag || !dist) return;

      const aspectW = ratio[0];
      const aspectH = ratio[1];
      const diagInCm = diag * 2.54;

      const aspectRatio = Math.sqrt(aspectW ** 2 + aspectH ** 2);
      const widthCm = diagInCm * (aspectW / aspectRatio);

      const degPerUnit = 2 * Math.atan((widthCm / 2) / dist) * (180 / Math.PI);
      document.getElementById("degResult").textContent = degPerUnit.toFixed(2);
    }
  </script>
</body>
</html>
