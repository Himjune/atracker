<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Айтрекинг: фиксации и AOI</title>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", sans-serif;
      line-height: 1.5;
      background-color: #f7f7f7;
      color: #222;
      overflow-y: scroll;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: stretch;
    }

    .block {
      width: 100%;
      padding: 2rem;
      box-sizing: border-box;
      background-color: #ffffff;
      border-bottom: 1px solid #ddd;
    }

    h1, h2 {
      margin-top: 0;
    }

    canvas {
      display: block;
      margin: 1rem auto;
      width: calc(100% - 2rem);
      height: auto;
      aspect-ratio: 16 / 9;
      border: 2px solid #444;
      background-color: #eaeaea;
    }

    .participant-controls {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    .participant-controls label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .participant-controls input[type="text"] {
      flex: 1;
    }
  </style>
</head>
<body>
  <div class="container">
    <section class="block" id="intro">
      <h1>Анализ айтрекингового чтения</h1>
      <p>Загрузите изображение, Excel с фиксациями и JSON с AOI для визуального анализа.</p>
    </section>

    <section class="block" id="upload-image">
      <h2>1. Загрузка изображения</h2>
      <input type="file" id="imageLoader" accept="image/*" />
    </section>

    <section class="block" id="upload-data">
      <h2>2. Загрузка фиксаций (.xlsx)</h2>
      <input type="file" id="dataLoader" accept=".xlsx" />
      <div id="participantList" class="participant-controls"></div>
      <button onclick="playFixations()">▶ Воспроизвести</button>
    </section>

    <section class="block" id="fixation-stats">
      <h2>6. Статистика фиксаций</h2>
      <ul id="fixationSummary"></ul>
    </section>

    <section class="block" id="upload-aoi">
      <h2>3. Загрузка AOI (.json)</h2>
      <input type="file" id="aoiLoader" accept=".json" />
    </section>

    <section class="block" id="settings-block">
      <h2>4. Настройки экрана</h2>
      <label>Диагональ монитора (дюймы): <input type="number" id="screenDiagonal" value="24" step="0.1"></label><br>
      <label>Соотношение сторон: <input type="text" id="aspectRatio" value="16:9"></label><br>
      <label>Расстояние от глаз до экрана (см): <input type="number" id="viewDistance" value="60"></label><br>
      <p id="degPerUnit">Градусы на единицу нормированной координаты: <span id="degResult">42.63</span></p>
      <button onclick="calculateVisualAngle()">Вычислить</button>
    </section>

    <section class="block" id="visualization">
      <h2>5. Визуализация</h2>
      <canvas id="canvas"></canvas>
    </section>
  </div>

  <script src="./xlsx.full.min.js"></script>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    var degPerUnit = 42.5;
    var velocityThresholdDegPerSec = 70;
    var fixTMin = 0.06;
    const speedScale = 2.0;

    function calcGrads(array) {

    }

    function medFilter(p, c, n) { //[prev, cur, next]
      let buf = ([p, c, n]).sort();
      if (c>buf[1]) {
        return buf[1];
      }
      return c;
    }
    function formFiltered() {
      participants.forEach(p => {
        p.filtered = [p.data[0]];
        for (let i = 1; i < p.data.length-1; i++) {
          const point = p.data[i];
          let x = medFilter(p.filtered[i-1].x, point.x, p.data[i+1].x);
          let y = medFilter(p.filtered[i-1].y, point.y, p.data[i+1].y);

          point.filtered = (x!=point.x || y!=point.y);
          point.x = x;
          point.y = y;
          p.filtered.push(point);
        }
        p.filtered.push(p.data.at(-1));
      });
    }

    function getGradVelocity(p1, p2) {
      const dt = (p2.time - p1.time)
      if (dt <= 0) return 0;

      const dx = (p2.x - p1.x) * degPerUnit;
      const dy = (p2.y - p1.y) * degPerUnit;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const velosity = dist / dt;
      //console.log(velosity, p2, p1, dx, dy, dist, dt)
      return velosity;
    }

    function centroidData(array) {
      const res = {x: 0, y: 0, r: 0};
      for (let index = 0; index < array.length; index++) {
        const element = array[index];
        res.x += element.x;
        res.y += element.y;
      }
      res.x /= array.length;
      res.y /= array.length;

      
      for (let index = 0; index < array.length; index++) {
        const element = array[index];
        const rad = Math.sqrt(res.x*res.x+res.y+res.y);
        if (rad > res.r) res.r = rad;
      }
      return res;
    }

    function calculateFixationsSaccades() {
      degPerUnit = parseFloat(document.getElementById("degResult").textContent);
      const threshold = velocityThresholdDegPerSec;


      participants.forEach(p => {
        let isPrevFix = getGradVelocity(p.filtered[0], p.filtered[1]) < threshold;
        let isFix = false;
        p.fixations = [{data: []}];
        p.saccades = [{data: []}];
        p.groups = [{isFixation: false, data: []}];

        ctx.lineWidth = 1.0;
        let fixGroup = [];
        for (let i = 0; i < p.data.length-1; i++) { //-1?  
          const p1 = p.filtered[i];
          const p2 = p.filtered[i+1];
          let vR = getGradVelocity(p.data[i], p.data[i+1]); 
          let velocity = getGradVelocity(p1, p2); 
          p1.velocity = velocity;
          isFix = velocity < threshold;

          //console.log(isFix, velocity < threshold, velocity, threshold, p1)

          if (isFix) {                  // fix point encountered
            fixGroup.push(p1);
          } else {                      // sac point encountered
            //console.log("fx", fixGroup)
            if (fixGroup.length > 1) {  // if we had fix points before cur sac point
              //console.log("cd", fixGroup.at(-1).time - fixGroup[0].time )
              if (fixGroup.at(-1).time - fixGroup[0].time < fixTMin) {  // small fix, add to prev sac
                p.groups.at(-1).data.push(...fixGroup);
                fixGroup = [];
              } else {                  // fixGroup is correct, add it to groups and start new sac
                p.groups.push({isFix: true, data: [...fixGroup]});
                p.groups.push({isFix: false, data: []});
                fixGroup = [];
              }
            }
            p.groups.at(-1).data.push(p1);
          }
        }
        // we are losing last point here...

        let left = 0;
        p.groups.forEach(g => {
          g.centroid = centroidData(g.data);
          g.time = g.data[0].time;
          for (let i = 0; i < g.data.length; i++) { //-1?
            const velocity = g.data[i].velocity; 
          
            if (g.isFix)
              ctx.strokeStyle = "darkred";
            else 
              ctx.strokeStyle = "red";
            ctx.beginPath(); // Start a new path
            ctx.moveTo(left+i+0.5, 0);
            ctx.lineTo(left+i+0.5, 2.5);
            ctx.lineTo(left+i+0.5, velocity/speedScale+0.5);
            ctx.closePath();
            ctx.stroke();

          };
          
          if (g.isFix) {
            ctx.strokeStyle = "darkblue";
          } else {
            ctx.strokeStyle = "blue";
          }
          ctx.beginPath(); // Start a new path
          ctx.moveTo(left+0.5, threshold/speedScale+0.5);
          ctx.lineTo(left+g.data.length+0.5, threshold/speedScale+0.5);
          ctx.closePath();
          ctx.stroke();
          left += g.data.length;
        });

      
      });
      console.log(participants);
    }

    const participantListDiv = document.getElementById("participantList");

    let image = new Image();
    let participants = [];
    let aoiList = [];
    let animationFrame = null;
    let playbackIndex = 0;

    document.getElementById("imageLoader").addEventListener("change", handleImage, false);
    document.getElementById("dataLoader").addEventListener("change", handleData, false);
    document.getElementById("aoiLoader").addEventListener("change", handleAoi, false);
    window.addEventListener("resize", drawImageAndFixations);

    function resizeCanvasToDisplaySize() {
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.width * 9 / 16;
    }

    function getRandomColor() {
      const r = Math.floor(Math.random() * 200);
      const g = Math.floor(Math.random() * 200);
      const b = Math.floor(Math.random() * 200);
      return `rgb(${r},${g},${b})`;
    }

    function handleImage(e) {
      const reader = new FileReader();
      reader.onload = function (event) {
        image.onload = function () {
          resizeCanvasToDisplaySize();
          drawImageAndFixations();
        };
        image.src = event.target.result;
      };
      reader.readAsDataURL(e.target.files[0]);
    }

    function handleData(e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (evt) {
        const data = new Uint8Array(evt.target.result);
        const workbook = XLSX.read(data, { type: "array" });
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

        let current = null;
        let count = 0;
        participants = [];

        rows.forEach(row => {
          if (!row || row.length < 2) return;
          const header = String(row[0]).trim();
          if (header === "TIME" && row[1] === "Valid") {
            count++;
            current = {
              name: file.name.replace(/\.xlsx$/, '') + "_P" + count,
              data: [],
              color: getRandomColor(),
              visible: true
            };
            participants.push(current);
          } else if (current && row.length >= 8) {
            current.data.push({
              time: +row[0],
              time2: +row[1],
              validity: +row[2],
              x: +row[3],
              y: +row[4],
              z: +row[5],
              lp: +row[6],
              rp: +row[7]
            });
          }
        });
        formFiltered();
        calculateFixationsSaccades();
        updateParticipantUI();
        drawImageAndFixations();
      };
      reader.readAsArrayBuffer(file);
    }

    function updateParticipantUI() {
      participantListDiv.innerHTML = "";
      participants.forEach((p, i) => {
        const label = document.createElement("label");
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = p.visible;
        checkbox.addEventListener("change", () => {
          p.visible = checkbox.checked;
          drawImageAndFixations();
        });

        const input = document.createElement("input");
        input.type = "text";
        input.value = p.name;
        input.addEventListener("input", () => {
          p.name = input.value;
        });

        label.appendChild(checkbox);
        label.appendChild(input);
        participantListDiv.appendChild(label);
      });
    }

    function handleAoi(e) {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (event) {
        try {
          const json = JSON.parse(event.target.result);
          aoiList = json.list || [];
          drawImageAndFixations();
        } catch (err) {
          alert("Ошибка при чтении AOI-файла.");
        }
      };
      reader.readAsText(file);
    }

    function drawImageAndFixations(showCount = Infinity) {
      const stats = [];
      if (!image.src) return;
      resizeCanvasToDisplaySize();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
      ctx.lineWidth = 1;

      const scaleX = canvas.width;
      const scaleY = canvas.height;

      participants.forEach(p => {
        if (!p.visible) return;
        ctx.fillStyle = p.color;
        const data = p.data.slice(0, showCount);
        data.forEach(pt => {
          if (pt.validity > 0 && pt.x >= 0 && pt.x <= 1 && pt.y >= 0 && pt.y <= 1) {
            const cx = pt.x * scaleX;
            const cy = pt.y * scaleY;
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        });

      });
      updateFixationStats(stats);

      if (aoiList.length > 0) {
        aoiList.forEach((aoi) => {
          const left = aoi.left * canvas.width;
          const top = aoi.top * canvas.height;
          const right = aoi.right * canvas.width;
          const bottom = aoi.bottom * canvas.height;
          const width = right - left;
          const height = bottom - top;

          ctx.strokeStyle = "rgba(0,195,0,0.8)";
          ctx.lineWidth = 2;
          ctx.strokeRect(left, top, width, height);

          if (aoi.name) {
            ctx.font = "14px sans-serif";
            ctx.fillStyle = "rgba(0,0,0,0.7)";
            ctx.fillText(aoi.name, left + 4, top + 16);
          }
        });
      }
    }

    function updateFixationStats(stats) {
      const list = document.getElementById("fixationSummary");
      list.innerHTML = "";
      stats.forEach(s => {
        const li = document.createElement("li");
        li.textContent = s;
        list.appendChild(li);
      });
    }

    function playFixations() {
      cancelAnimationFrame(animationFrame);
      let maxPoints = Math.max(...participants.map(p => p.data.length));
      playbackIndex = 0;

      function step() {
        playbackIndex++;
        drawImageAndFixations(playbackIndex);
        if (playbackIndex < maxPoints) {
          animationFrame = requestAnimationFrame(step);
        }
      }

      step();
    }


    function calculateVisualAngle() {
      const diag = parseFloat(document.getElementById("screenDiagonal").value);
      const ratio = document.getElementById("aspectRatio").value.split(":").map(Number);
      const dist = parseFloat(document.getElementById("viewDistance").value);
      if (ratio.length !== 2 || !diag || !dist) return;

      const aspectW = ratio[0];
      const aspectH = ratio[1];
      const diagInCm = diag * 2.54;

      const aspectRatio = Math.sqrt(aspectW ** 2 + aspectH ** 2);
      const widthCm = diagInCm * (aspectW / aspectRatio);

      const degPerUnit = 2 * Math.atan((widthCm / 2) / dist) * (180 / Math.PI);
      document.getElementById("degResult").textContent = degPerUnit.toFixed(2);
    }
  </script>
</body>
</html>
